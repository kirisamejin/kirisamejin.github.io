---
title: 莫比乌斯
teaser:
category:
tags: [mobius inversion]
---

----------------------------------------

#mobius

沈阳网络赛的两道
G
用 [(m,i)==1] 和  $$\sum_{d\mid (m,i)}\mu(d)$$ 等价的性质
然后交换一下次序
```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
int n,m,inv6;
const int mod = 1e9+7;
vector<int> fac;
inline int factorize(int m) {
    for(int i=2;i*i<=m;++i) {
        if(m%i==0) {
            fac.push_back( i );
            while(m%i==0) m/=i;
        }
    }
    if(m!=1) fac.push_back( m );
    return fac.size();
}
inline int get(ll i,ll d) {
    ll res = 0;
    res = i*(i+1)%mod*(2*i+1)%mod*inv6%mod*d%mod*d%mod;
    res = (res + (i*(i+1)/2)%mod*d%mod)%mod;
    return res;
}
ll qpow(ll a,ll b) {ll res=1;for(;b;(b&1)?res=(res*a)%mod:0,a=(a*a)%mod,b>>=1); return res;}
int main() {
    inv6 = qpow(6,mod-2);
    while(~scanf("%d%d",&n,&m)) {
        fac.clear();
        int len = factorize(m);
        int ma = (1<<len) ;
        int ans = 0;
        for(int bt=0;bt<ma;++bt) {
            ll d = 1, miu = 1;
            for(int i=0;i<len;++i) {
                if( bt&(1<<i) ) d *= fac[i], miu*=-1;
            }
            ll i=n/d;
            ans = ( (ans + miu*get(i,d))%mod + mod ) % mod;
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```
C
把外面的交换次序得到(n-i+1)f(i)，
然后用上
$$\lambda(n)=\sum_{d^2\mid n}\mu(n/d)\quad\text{and}\quad\mu^2(n)=\sum_{d^2\mid n}\mu(d)$$

[click this for proof](https://math.stackexchange.com/questions/1053000/prove-lambdan-sum-d2n-mun-d2-and-mu2n-sum-d2n-mud)
右边这个公式 和C题一样再交换一下就演出来了

对不起我就是个傻逼，写个筛法写了三处错误我也是佩服我自己。
```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
__int128 n,p;
inline ll cal2(__int128 n1) {
    return n1*(n1+1)%(6*p)*(2*n1+1)%(6*p)/6;
}
inline ll cal3(__int128 n1) {
    __int128 tmp = n1*(n1+1)%(2*p)/2;
    return tmp*tmp%p;
}
const int N = 1e5;
int v[N+100],pr[N+100],tot,mu[N+100];
int si() {
    mu[1]=1;
    for(int i=2;i<=N;++i) {
        if(!v[i]) pr[++tot]=i, mu[i]=-1;
        //else {
            for(int j=1;j<=tot&&i*pr[j]<=N;++j) {
                v[i*pr[j]] = 1;
                if(i%pr[j]==0) {
                    mu[i*pr[j]] = 0;
                    break;
                } else mu[i*pr[j]] = mu[i] * mu[pr[j]];
            }
        //}
    }
}
int main() {
    si(); 
    while(~scanf("%lld%lld",&n,&p)) {
        __int128 ans = 0, t, t2;
        for(ll i=1;i*i<=n;++i) {
            t=i*i;
            t2=t*t%p;
            if(mu[i]) {
                ans=(ans+mu[i]*(t2*(n+1)%p)*cal2(n/(ll)t)%p)%p;
                ans=(ans-mu[i]*((t2*t)%p)*cal3(n/(ll)t)%p)%p;
            }
        }
        ans = (ans+p)%p;
        printf("%lld\n", (ll)ans );
    }
    return 0;
}
```
